-- LocalScript trong StarterPlayerScripts
-- FULL: UI 4 n√∫t + Anti-check (c∆° b·∫£n) + Panic + Conservative Mode (client-only highlights)
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local backpack = player:WaitForChild("Backpack")

-- ============================
-- ‚ö†Ô∏è C·∫§U H√åNH ANTI / SAFE MODE
-- ============================
local SAFE = true -- b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô an to√†n
local MIN_FIRE_INTERVAL = 0.45 -- kho·∫£ng th·ªùi gian t·ªëi thi·ªÉu gi·ªØa 2 l·∫ßn FireServer t·ªõi c√πng 1 remote (s)
local MAX_ERRORS_BEFORE_STOP = 10 -- n·∫øu qu√° nhi·ªÅu l·ªói th√¨ auto d·ª´ng t·∫•t c·∫£
local MOVE_TWEEN_TIME_MIN = 0.18
local MOVE_TWEEN_TIME_MAX = 0.45

-- tr·∫°ng th√°i runtime ƒë·ªÉ theo d√µi l·ªói / rate-limit
local remoteLastFire = {}
local errorCount = 0
local emergencyStopped = false

local function safeLog(...)
    print("[CollectorSafe]", ...)
end

local function recordError(msg)
    errorCount = errorCount + 1
    warn("[CollectorSafe] Error:", msg, "(" .. errorCount .. ")")
    if errorCount >= MAX_ERRORS_BEFORE_STOP then
        emergencyStopped = true
        safeLog("‚ö†Ô∏è Emergency stop activated ‚Äî qu√° nhi·ªÅu l·ªói. T·∫Øt t·∫•t c·∫£ auto.")
    end
end

local function resetErrors()
    errorCount = 0
    emergencyStopped = false
end

-- safe fire: tr√°nh spam remote
local function safeFire(remote, ...)
    if not remote or (not remote:IsA("RemoteEvent") and not remote:IsA("RemoteFunction")) then return end
    if emergencyStopped then return end

    local id = tostring(remote)
    local now = tick()
    local last = remoteLastFire[id] or 0
    local minInterval = MIN_FIRE_INTERVAL
    if not SAFE then minInterval = 0.12 end

    if now - last < minInterval then
        task.wait(minInterval - (now - last) + math.random() * 0.1)
    end

    remoteLastFire[id] = tick()
    local ok, res = pcall(function()
        if remote:IsA("RemoteEvent") then
            remote:FireServer(...)
            return true
        else
            return remote:InvokeServer(...)
        end
    end)
    if not ok then
        recordError(res)
    else
        if errorCount > 0 then
            errorCount = math.max(0, errorCount - 1)
        end
    end
    return ok, res
end

-- safe teleport: tween HRP thay v√¨ set CFrame tr·ª±c ti·∫øp
local function safeTeleportTo(cframe)
    if emergencyStopped then return false end
    if not cframe then return false end
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChildWhichIsA("BasePart", true)
    if not hrp then return false end

    local duration = math.clamp((hrp.Position - cframe.Position).Magnitude / 60, MOVE_TWEEN_TIME_MIN, MOVE_TWEEN_TIME_MAX)
    local goal = {CFrame = cframe}
    local tweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Linear)
    local ok, err = pcall(function()
        local tween = TweenService:Create(hrp, tweenInfo, goal)
        tween:Play()
        tween:Wait()
    end)
    if not ok then
        recordError(err)
        pcall(function() hrp.CFrame = cframe end)
    end
    return true
end

-- briefly anchor parts safely then unanchor (but h·∫°n ch·∫ø anchoring nhi·ªÅu ph·∫ßn ƒë·ªÉ tr√°nh ph√°t hi·ªán)
local function safeAnchorCharacter(anchorTime)
    anchorTime = anchorTime or 0.6
    local char = player.Character
    if not char then return end
    local anchoredParts = {}
    for _, part in ipairs(char:GetDescendants()) do
        if part:IsA("BasePart") and not part.Anchored then
            local ok, err = pcall(function() part.Anchored = true end)
            if ok then table.insert(anchoredParts, part) end
        end
    end

    task.delay(anchorTime, function()
        for _, p in ipairs(anchoredParts) do
            pcall(function() p.Anchored = false end)
        end
    end)
end

-- ============================
-- ü•≠ Danh s√°ch tr√°i
-- ============================
local fruitNames = {
    "Barrier Fruit", "Bomb Fruit", "Swim Fruit", "Slip Fruit", "Chop Fruit", "Clone Fruit",
    "Hot Fruit", "Clear Fruit", "Float Fruit", "Spin Fruit", "Spring Fruit", "Smelt Fruit",
    "Diamond Fruit", "Gum Fruit", "Hobby Fruit", "Candy Fruit", "Chilly Fruit", "Gas Fruit",
    "Dark Fruit", "Flare Fruit", "Light Fruit", "Smoke Fruit", "Sand Fruit", "Rumble Fruit",
    "Magma Fruit", "Ope Fruit", "Snow Fruit", "Gravity Fruit", "Quake Fruit", "Venom Fruit",
    "Shadow Fruit", "Phoenix Fruit"
}

-- l·∫•y HRP an to√†n
local function getHRP()
    local character = player.Character or player.CharacterAdded:Wait()
    return character:WaitForChild("HumanoidRootPart")
end

-- l·∫•y CFrame c·ªßa object (h√†m s·ª≠ d·ª•ng cho NPC v√† tr√°i)
local function getObjectCFrame(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then
        return obj.CFrame
    elseif obj:IsA("Model") then
        if obj.PrimaryPart then
            return obj.PrimaryPart.CFrame
        else
            local bp = obj:FindFirstChildWhichIsA("BasePart", true)
            if bp then return bp.CFrame end
        end
    end
    return nil
end

-- collect fruit: teleport g·∫ßn tr√°i -> click
local function collectFruit(fruit)
    if not fruit then return end
    local targetCF = getObjectCFrame(fruit)
    if not targetCF then return end
    targetCF = targetCF + Vector3.new(0, 3, 0)

    local ok, err = pcall(function()
        if SAFE then
            safeTeleportTo(targetCF)
            task.wait(0.25 + math.random() * 0.15)
        else
            local hrp = getHRP()
            hrp.CFrame = targetCF
            task.wait(0.18)
        end
    end)
    if not ok then recordError(err) end

    local click = fruit:FindFirstChildWhichIsA("ClickDetector", true)
    if click then
        local okf, e = pcall(function() fireclickdetector(click) end)
        if not okf then recordError(e) end
    end
end

-- ============================
-- üí∞ Chest Helper
-- ============================
local function getChestPosition(c)
    if c:IsA("BasePart") then
        return c.Position
    elseif c:IsA("Model") then
        if c.PrimaryPart then
            return c.PrimaryPart.Position
        else
            local bp = c:FindFirstChildWhichIsA("BasePart", true)
            if bp then return bp.Position end
        end
    end
    return nil
end

-- ============================
-- ü•§ Juice Routine Helper
-- ============================
local cratesFolder = workspace:WaitForChild("Barrels"):WaitForChild("Crates")

local function getPosition(obj)
    if obj:IsA("BasePart") then
        return obj.Position
    elseif obj:IsA("Model") then
        if obj.PrimaryPart then
            return obj.PrimaryPart.Position
        else
            local bp = obj:FindFirstChildWhichIsA("BasePart", true)
            if bp then return bp.Position end
        end
    end
    return nil
end

local function teleportAndClick(obj)
    local pos = getPosition(obj)
    if pos then
        local ok, err = pcall(function()
            safeTeleportTo(CFrame.new(pos + Vector3.new(0, 5, 0)))
            task.wait(0.15 + math.random() * 0.2)
        end)
        if not ok then recordError(err) end

        local cd = obj:FindFirstChildWhichIsA("ClickDetector", true)
        if cd then
            local okf, e = pcall(function() fireclickdetector(cd) end)
            if not okf then recordError(e) end
        end
    end
end

local function equipAndClick(tool)
    if not tool or not tool:IsA("Tool") then return end
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid")
    pcall(function() humanoid:EquipTool(tool) end)

    local timeout, waited = 3, 0
    while tool.Parent ~= character and waited < timeout do
        task.wait(0.1)
        waited += 0.1
    end

    if tool.Parent == character then
        pcall(function()
            if typeof(tool.Activate) == "function" then
                tool:Activate()
                task.wait(0.15)
                if typeof(tool.Deactivate) == "function" then
                    tool:Deactivate()
                end
            else
                for _, desc in ipairs(tool:GetDescendants()) do
                    if desc:IsA("ClickDetector") then
                        fireclickdetector(desc)
                    end
                end
            end
        end)
    end
end

local juiceList = {
    "Coconut Milk", "Fruit Juice", "Pumpkin Juice", "Sour Juice",
    "Pear Juice", "Banana Juice", "Apple Juice"
}

local function waitForAnyJuice()
    while true do
        for _, name in ipairs(juiceList) do
            if backpack:FindFirstChild(name) then
                return true
            end
        end
        task.wait(0.2)
        if emergencyStopped then return false end
    end
end

local function fullRoutine()
    if emergencyStopped then return end
    -- B1: crates
    for _, crate in ipairs(cratesFolder:GetChildren()) do
        if emergencyStopped then break end
        teleportAndClick(crate)
        task.wait(0.25 + math.random() * 0.2)
    end

    -- B2: mixers
    local kitchenOK, kitchen = pcall(function()
        return workspace.Island8.Kitchen:GetChildren()[3].JuicingBowl
    end)
    if kitchenOK and kitchen then
        local mixer1 = kitchen:FindFirstChild("Mixer1")
        local mixer2 = kitchen:FindFirstChild("Mixer2")
        if mixer1 then teleportAndClick(mixer1) task.wait(0.4) end
        if mixer2 then teleportAndClick(mixer2) task.wait(0.4) end
    end

    if not waitForAnyJuice() then return end

    -- B3: Stone[85] (n·∫øu c√≥)
    local okStone, stone85 = pcall(function()
        return workspace.IslandSnowyMountains.Stone:GetChildren()[85]
    end)
    if okStone and stone85 then
        teleportAndClick(stone85)
        task.wait(0.4)
    end

    -- B4: d√πng juice
    local hasJuice = true
    while hasJuice and not emergencyStopped do
        hasJuice = false
        for _, name in ipairs(juiceList) do
            local tool = backpack:FindFirstChild(name)
            if tool then
                hasJuice = true
                equipAndClick(tool)
                task.wait(0.35 + math.random() * 0.25)
            end
        end
    end
end

-- ============================
-- üéØ AUTO PACKAGE + TELE NPC (TH√äM)
-- ============================
local function getPackageRemote()
    local ok, remote = pcall(function()
        return workspace
            :WaitForChild("Merchants")
            :WaitForChild("QuestFishMerchant")
            :WaitForChild("Clickable")
            :WaitForChild("Retum")
    end)
    return ok and remote or nil
end

local function autoGetPackage()
    local tries = 0
    while tries < 10 and not emergencyStopped do
        local remote = getPackageRemote()
        if remote and remote:IsA("RemoteEvent") then
            safeFire(remote, "Package")
            task.wait(0.35 + math.random() * 0.2)
            safeFire(remote, "Close")
        end

        local bp = player:FindFirstChild("Backpack")
        local ch = player.Character
        if (bp and bp:FindFirstChild("Package")) or (ch and ch:FindFirstChild("Package")) then
            safeLog("‚úÖ ƒê√£ l·∫•y Package.")
            return true
        end

        tries += 1
        task.wait(0.45 + math.random() * 0.2)
    end
    warn("‚ö†Ô∏è Kh√¥ng th·ªÉ l·∫•y Package sau nhi·ªÅu l·∫ßn th·ª≠.")
    recordError("Kh√¥ng l·∫•y ƒë∆∞·ª£c Package")
    return false
end

local function equipAndActivatePackage()
    local bp = player:FindFirstChild("Backpack")
    if not bp then return false end

    local packageTool = bp:FindFirstChild("Package")
    if packageTool then
        local character = player.Character or player.CharacterAdded:Wait()
        packageTool.Parent = character
        if packageTool:IsA("Tool") then
            pcall(function() packageTool:Activate() end)
        end
        return true
    end

    return false
end

local function getNPCPositionCF(obj)
    if not obj then return nil end
    if obj:IsA("BasePart") then
        return obj.CFrame
    elseif obj:IsA("Model") then
        local part = obj:FindFirstChild("HumanoidRootPart") or obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart", true)
        if part then return part.CFrame end
    end
    return nil
end

local function teleportToNPC(npc)
    if emergencyStopped then return end
    local hrp = getHRP()
    if not hrp then return end
    local npcCF = getNPCPositionCF(npc)
    if not npcCF then return end

    pcall(function()
        hrp.AssemblyLinearVelocity = Vector3.zero
        hrp.AssemblyAngularVelocity = Vector3.zero
    end)

    safeTeleportTo(npcCF * CFrame.new(0, 0, 3.1))
    safeAnchorCharacter(0.55)
    task.wait(0.12 + math.random() * 0.15)
end

local merchantNames = {
    "AffinityMerchant",
    "BetterDrinkMerchant",
    "Boat1Merchant",
    "Boat2Merchant",
    "Boat3Merchant",
    "Boat4Merchant",
    "Boat5Merchant",
    "DrinkMerchant",
    "EmoteMerchant",
    "ExpertiseMerchant",
    "FishMerchant",
    "FlailMerchant",
    "FriendMerchant",
    "KrizmaMerch",
    "QuestMerchant",
    "QuestMerchant2",
    "SniperMerchant",
    "SwordMerchant"
}

local function teleportAllMerchants()
    if emergencyStopped then return end
    local merchantsFolder = workspace:FindFirstChild("Merchants")
    if not merchantsFolder then
        warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y workspace.Merchants!")
        recordError("Kh√¥ng t√¨m th·∫•y Merchants folder")
        return
    end

    for _, name in ipairs(merchantNames) do
        if emergencyStopped then break end
        local npc = merchantsFolder:FindFirstChild(name)
        if npc then
            local ok, err = pcall(function() teleportToNPC(npc) end)
            if not ok then recordError(err) end
            safeLog("‚úÖ Tele t·ªõi " .. name)
        else
            warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y NPC:", name)
        end
        task.wait(0.7 + math.random() * 0.4)
    end
end

local function packageNPCLoop()
    if emergencyStopped then return end
    local ok = autoGetPackage()
    if not ok then return end
    equipAndActivatePackage()
    teleportAllMerchants()
end

-- ============================
-- üé® T·∫°o UI (S·ª¨A L·∫†I CHO 4 N√öT ƒê·ªÄU)
-- ============================
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CollectorMenu"
screenGui.ResetOnSpawn = false
screenGui.Parent = player:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 420, 0, 420)
frame.Position = UDim2.new(0.3, 0, 0.25, 0)
frame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
frame.BorderSizePixel = 0
frame.Visible = false
frame.Active = true
frame.Draggable = true
frame.Parent = screenGui

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 48)
title.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
title.Text = "Collector Menu"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.SourceSansBold
title.TextSize = 24
title.Parent = frame

local buttonHeight = 56
local buttonSpacing = 12
local function createButton(text, posY)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.8, 0, 0, buttonHeight)
    btn.Position = UDim2.new(0.1, 0, 0, posY)
    btn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    btn.Text = text
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = Enum.Font.SourceSans
    btn.TextSize = 20
    btn.Parent = frame
    return btn
end

local startY = 64

local fruitButton = createButton("Auto Fruit: OFF", startY)
local chestButton = createButton("Auto Chest: OFF", startY + buttonHeight + buttonSpacing)
local juiceButton = createButton("Auto Juice: OFF", startY + (buttonHeight + buttonSpacing) * 2)
local packageButton = createButton("Auto Package NPC: OFF", startY + (buttonHeight + buttonSpacing) * 3)

-- tr·∫°ng th√°i
_G.autoFruit = false
_G.autoChest = false
_G.autoJuice = false
_G.autoPackageNPC = false

fruitButton.MouseButton1Click:Connect(function()
    _G.autoFruit = not _G.autoFruit
    fruitButton.Text = "Auto Fruit: " .. (_G.autoFruit and "ON" or "OFF")
    if not _G.autoFruit then resetErrors() end
end)

chestButton.MouseButton1Click:Connect(function()
    _G.autoChest = not _G.autoChest
    chestButton.Text = "Auto Chest: " .. (_G.autoChest and "ON" or "OFF")
    if not _G.autoChest then resetErrors() end
end)

juiceButton.MouseButton1Click:Connect(function()
    _G.autoJuice = not _G.autoJuice
    juiceButton.Text = "Auto Juice: " .. (_G.autoJuice and "ON" or "OFF")
    if not _G.autoJuice then resetErrors() end
end)

packageButton.MouseButton1Click:Connect(function()
    _G.autoPackageNPC = not _G.autoPackageNPC
    packageButton.Text = "Auto Package NPC: " .. (_G.autoPackageNPC and "ON" or "OFF")
    if not _G.autoPackageNPC then resetErrors() end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.Equals then
        frame.Visible = not frame.Visible
    end
end)

-- ============================
-- ‚ôªÔ∏è V√≤ng l·∫∑p Auto (gi·ªØ nguy√™n + th√™m m·ªõi)
-- ============================
task.spawn(function()
    while task.wait(1) do
        if emergencyStopped then
            _G.autoFruit = false
            _G.autoChest = false
            _G.autoJuice = false
            _G.autoPackageNPC = false
            fruitButton.Text = "Auto Fruit: OFF"
            chestButton.Text = "Auto Chest: OFF"
            juiceButton.Text = "Auto Juice: OFF"
            packageButton.Text = "Auto Package NPC: OFF"
            safeLog("All autos disabled due to emergency stop.")
            break
        end

        if _G.autoFruit then
            local maxPerCycle = 30
            local collected = 0
            for _, name in ipairs(fruitNames) do
                if collected >= maxPerCycle or emergencyStopped then break end
                for _, obj in ipairs(workspace:GetChildren()) do
                    if obj.Name == name then
                        pcall(function() collectFruit(obj) end)
                        collected = collected + 1
                        task.wait(0.35 + math.random() * 0.25)
                        if collected >= maxPerCycle then break end
                    end
                end
            end
        end
    end
end)

task.spawn(function()
    while task.wait(1) do
        if emergencyStopped then break end
        if _G.autoChest then
            local chests = workspace:FindFirstChild("Chests")
            if chests then
                for _, c in ipairs(chests:GetChildren()) do
                    if emergencyStopped then break end
                    local pos = getChestPosition(c)
                    if pos then
                        pcall(function()
                            safeTeleportTo(CFrame.new(pos + Vector3.new(0, 5, 0)))
                        end)
                    end
                    task.wait(0.45 + math.random() * 0.25)
                end
            end
        end
    end
end)

task.spawn(function()
    while task.wait(1) do
        if emergencyStopped then break end
        if _G.autoJuice then
            pcall(fullRoutine)
            task.wait(0.6 + math.random() * 0.5)
        end
    end
end)

task.spawn(function()
    while task.wait(1) do
        if emergencyStopped then break end
        if _G.autoPackageNPC then
            pcall(function()
                packageNPCLoop()
            end)
            task.wait(1.0 + math.random() * 0.9)
        end
    end
end)

-- ============================
-- ‚ú® H·ªó tr·ª£: reset emergency th·ªß c√¥ng (ch·ªâ d√πng dev)
-- ============================
_G.resetCollectorSafe = function()
    resetErrors()
    safeLog("Reset errors manual.")
end

-- ============================
-- PANIC + CONSERVATIVE MODE (AN TO√ÄN)
-- ============================
_G.conservativeMode = false
local highlights = {}

-- T·∫°o Billboard ƒë·ªÉ highlight object (ch·ªâ client-side, an to√†n)
local function makeHighlight(obj, labelText)
    if not obj or (not obj:IsA("BasePart") and not obj:IsA("Model")) then return end
    local part = obj
    if obj:IsA("Model") then
        part = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart", true)
    end
    if not part then return end

    if highlights[part] and highlights[part].Parent then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "CollectorHighlight"
    billboard.Adornee = part
    billboard.Size = UDim2.new(0,140,0,44)
    billboard.AlwaysOnTop = true
    billboard.ResetOnSpawn = false

    local label = Instance.new("TextLabel", billboard)
    label.Size = UDim2.new(1,0,1,0)
    label.BackgroundTransparency = 0.6
    label.BackgroundColor3 = Color3.fromRGB(30,30,30)
    label.TextColor3 = Color3.fromRGB(255,255,255)
    label.Text = labelText or (obj.Name or "Item")
    label.Font = Enum.Font.SourceSansBold
    label.TextScaled = true

    billboard.Parent = player:WaitForChild("PlayerGui")
    highlights[part] = billboard
end

local function clearHighlights()
    for part, gui in pairs(highlights) do
        if gui and gui.Parent then
            pcall(function() gui:Destroy() end)
        end
    end
    highlights = {}
end

-- Panic: d·ª´ng m·ªçi auto, unanchor nh√¢n v·∫≠t, reset l·ªói
local function panicStopAll()
    _G.autoFruit = false
    _G.autoChest = false
    _G.autoJuice = false
    _G.autoPackageNPC = false
    -- unanchor parts
    local char = player.Character
    if char then
        for _, p in ipairs(char:GetDescendants()) do
            if p:IsA("BasePart") then
                pcall(function() p.Anchored = false end)
            end
        end
    end
    emergencyStopped = false
    resetErrors()
    clearHighlights()
    safeLog("PANIC: All automation stopped.")
end

-- Conservative scan loop (client-only scan and highlight)
task.spawn(function()
    while true do
        task.wait(2)
        if _G.conservativeMode then
            clearHighlights()
            for _, name in ipairs(fruitNames) do
                for _, obj in ipairs(workspace:GetChildren()) do
                    if obj.Name == name then
                        pcall(function() makeHighlight(obj, "Fruit: "..name) end)
                    end
                end
            end
            local chests = workspace:FindFirstChild("Chests")
            if chests then
                for _, c in ipairs(chests:GetChildren()) do
                    pcall(function() makeHighlight(c, "Chest") end)
                end
            end
        else
            if next(highlights) then
                clearHighlights()
            end
        end
        if emergencyStopped then
            if next(highlights) then clearHighlights() end
        end
    end
end)

-- Th√™m Panic + Conservative n√∫t v√†o UI
pcall(function()
    if frame and frame:IsA("Frame") then
        local btnPanic = Instance.new("TextButton")
        btnPanic.Size = UDim2.new(0.28,0,0,40)
        btnPanic.Position = UDim2.new(0.06,0,0.86,0)
        btnPanic.BackgroundColor3 = Color3.fromRGB(180,50,50)
        btnPanic.Text = "PANIC"
        btnPanic.TextColor3 = Color3.new(1,1,1)
        btnPanic.Font = Enum.Font.SourceSansBold
        btnPanic.TextSize = 16
        btnPanic.Parent = frame
        btnPanic.MouseButton1Click:Connect(panicStopAll)

        local btnCons = Instance.new("TextButton")
        btnCons.Size = UDim2.new(0.6,0,0,40)
        btnCons.Position = UDim2.new(0.34,0,0.86,0)
        btnCons.BackgroundColor3 = Color3.fromRGB(70,70,70)
        btnCons.Text = "Conservative: OFF"
        btnCons.TextColor3 = Color3.new(1,1,1)
        btnCons.Font = Enum.Font.SourceSans
        btnCons.TextSize = 16
        btnCons.Parent = frame
        btnCons.MouseButton1Click:Connect(function()
            _G.conservativeMode = not _G.conservativeMode
            btnCons.Text = "Conservative: " .. (_G.conservativeMode and "ON" or "OFF")
            if not _G.conservativeMode then clearHighlights() end
        end)
    end
end)

-- ============================
-- üìå K·∫øt th√∫c script
-- ============================
safeLog("Collector script loaded. SafeMode:", SAFE)
